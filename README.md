# Evo_Pipetting_Optimiser

## Introduction
A frequent challenge in using the Tecan EVO is the flawed optimisation that EVOware conducts for basic worklist commands (A and D),
as produced by `robotools.EvoWorklist.transfer()`. The strategy it selects can often make pipetting slower, and B; commands 
`EvoWorklist.commit()` must be inserted between commands to stop the EVO from rearranging them inefficiently. It can even cause intermittent errors, where, if sample positions change, it may attempt to pipette a well with a tip that cannot reach that well, if the labware is near the top or bottom of the deck.

Additionally, a common use case for robotools is dilution/processing/preparation of several samples in a plate. In such cases,
the easiest way to translate the process to Python and robotools is to loop through each sample, and define the pipetting steps which 
must be conducted for that sample to be processed. Unfortunately, this leads to inefficient worklist commands, which pipette one sample at
a time. Previously, careful design and more complicated code was employed to pre-calculate the operations required for all samples,
then make fewer calls to `transfer()`, ideally only one (covering all samples) for each step in the process. This allowed several samples to
be pipetted at once, at the cost of making code more difficult to write and understand. Additionally, it could still fall victim to poor
optimisation from the EVOware side, and miss potential speed.

Thus an optimiser which tracks all operations a user wishes to conduct, before automatically grouping them into the most efficient order,
is desired. This package provides this, by providing an `auto_transfer` method which records the desired operations for later optimisation. When `commit` is called or the worklist is saved, the recorded operations are optimised and added to the worklist as advanced worklist commands.

WARNING: advanced worklist commands can cause damage if not used carefully. Ensure all grid and site locations specified are accurate.

### In scope
Optimisation of pipetting operations for an 8-tip LiHa on the Tecan EVO

Provision of an interface with minimal differences to existing robotools `EvoWorklist` and `transfer` funtionality so that operation is
understandable to existing users

Maintainence of pipetting order; no operations on a particular well shall be conducted in a different order to that which they were specified in code

Support for the existing composition tracking and reporting functionality in robotools

### Out of scope
Other liquid handlers or arms

Optimisation by using tip spreading - tips will only move with the minimum defined spread for each labware. Spreading tips to access seperated wells with subsequent tips would add significant complexity and is far more likely to cause errors from trying to move tips outside the bounds of the EVO.

## Overview and usage

### Installation

This package can be installed by:

1. `cd evo_pipetting_optimiser`
2. `pip install .`

### Deinstallation

You can just uninstall the package with:
 ```
 pip uninstall evo_pipetting_optimiser
 ```

### Usage
First import AutoWorklist and AdvancedLabware
```
from evo_pipetting_optimiser import AdvancedLabware, AutoWorklist
```

Create AdvancedLabware just as you would Labware, but with the added `location` parameter set to a tuple (grid, site) of the location of the labware on the EVO deck.
```
sample_plate = AdvancedLabware(
    "smp",
    8,
    12,
    min_volume=20,
    max_volume=10000,
    initial_volumes=5000,
    location=(41, 3),
)
```

You can define troughs as usual, but must set the location parameter afterwards.

```
reducing_trough = robotools.Trough(
        "Reducing",
        8,
        1,
        min_volume=50,
        max_volume=25_000,
        initial_volumes=25_000,
    )
reducing_trough.location = (4, 2)
```

Then, create an `AutoWorklist`. This is the same as `EvoWorklist`, but waste_location and cleaner_location must be specified as (grid, site) tuples.

```
with AutoWorklist("test.gwl", waste_location=(1, 2), cleaner_location=(1, 3),) as wl:
```

All `EvoWorklist` commands can be used as normal. For optimisation, the `auto_transfer` method must be used. This is nearly identical to `transfer` in use. The only difference is in the wash_scheme argument; only "D", 1, and None are supported.
```
wl.auto_transfer(
            sample_plate,
            sample_plate.wells[0, 1],
            dilution_plate,
            dilution_plate.wells[1, 0],
            1250,
            liquid_class="Water free dispense",
)
```

Washes are added with advanced worklist commands, rather than the usual basic W command - thus, seperate numbered schemes as defined in evoware are not available. Instead, wash parameters can be set with the set_wash_parameters method, i.e. 
`wl.set_wash_parameters(waste_vol=5.0)`. All arguments available to the `evo_wash` method can be set as parameters here, and will be applied to all washes generated by `auto_transfer`.

Only one set of parameters can be applied per optimisation. If you wish to change wash parameters, first apply the previous optimisation with `commit()`, then, change the parameters for the coming operations.

Likewise, commands other than `auto_transfer` cannot be added while optimisation is pending and has not been commited, as any other commands would be added to the worklist before the pending commands. Call `commit()` before using any other commands. If you do not call commit, it will be called automatically and generate a warning.

Decontamination washes are supported, through adding one or more decon troughs
`wl.set_wash_parameters(decon_troughs=[trough1, trough2])`, then using transfers with wash_scheme="D". The first trough in the list will be used until the volume tracking determines it does not have sufficient volume, then the next trough will be used. Parameters available for the decon wash are 
- `decon_liquid_class` - The liquid class for aspirating decon solution. Must be set before any decon is used.
- `decon_delay` - Delay to apply after aspirating the decon solution, to soak the insides of the tips
- `decon_excess_volume` - Volume of decon aspirated by each tip will be set equal to the volume that was aspirated by that tip in the transfer step, plus this excess volume. This is superior to EVOware decon, where only a single fixed volume can be set, and thus the maximum desired must be set and will be used for all decons.

These parameters are likewise set with `set_wash_parameters`.

To prevent the optimiser trying to move tips further than is physically possible on the deck, `offset_limit_up` and `offset_limit_down` parameters are available when creating AdvancedLabware.

`offset_limit_up` Limits the vertical translation upwards (towards the back of the evo) of tips accessing the labware, when used with `auto_transfer`
This is used for labware near the top of the evo deck, where not every row can be accessed by every tip
If set to an int, limits the upwards translation of the tips: 4 means the tips can shift no more than 4 rows above
their default position. I.e. tip 5 can access row A, but tip 6 cannot
If 0, no upwards shift is allowed
If none, no offset limit and any offsets are permitted
Setting a limit will reduce optimisation effectiveness and increase pipetting time

`offset_limit_down` likewise limits the movement of the tips downwards, useful for labware near the bottom of the evo deck.

After several `auto_transfer` operations but before a commit, you can call `report_ops` to see a list of operations that are pending.

A report will look like this, with the operation ID, the name and well of the source and destination, and the volume.
```
16:              smp-A01 to dilplate-A01         625.0ul
17:              smp-A01 to dilplate-A01         625.0ul
18:              smp-B01 to dilplate-A02         625.0ul
19:              smp-B01 to dilplate-A02         625.0ul
```

After a commit, the volumes and compositions of labware will reflect the operations applied, just as if `transfer` had been used. This, along with the `report` method of labware, can be used to validate pipetting was conducted as expected

Complete examples are available in the examples folder. Start with [example_basic_row_column.py](examples/example_basic_row_column.py)

## Architecture
This package is designed first to track the operations which a user wishes to conduct on all defined Labware, then rearrange the order of these operations
to achieve maximum pipetting efficiency, before adding them to a worklist with Advanced Worklist Commands (Aspirate and Dispense). This allows us to 
precisely define which tips should be used in which wells, and prevent EVOware's built in optimiser from changing our optimised order.

Some additional properties must be defined to allow us to automatically generate advanced worklist commands. E.g. each labware in use must have a location tuple
(grid, site) defined.

The `AutoWorklist` class is defined as an equivalent to `EvoWorklist`, but with additional functionality to enable this tracking and optimisation. Its use is identical to
`EvoWorklist`, except that a waste_location and cleaner_location must be specified, which allow us to generate advanced worklist Wash commands (as the basic worklist W command does not work in conjunction with advanced worklist Aspirate and Dispense) All functionality present in `EvoWorklist` is present and unchanged; you can use `.transfer` just as usual, and the corresponding operations will not be optimised.

A `TransferOperation` class is defined, which captures all the relevant details for a transfer from one well to another, including the plate and position of the source
and destination wells, the volume, and the liquid class. Each `TransferOperation` has a unique ID. The `auto_transfer` method, which is equivalent to `transfer` but adds optimisation, produces one `TransferOperation` for each well it is passed, recording the details appropriate to that well. It then adds all the ops to a set `pending_ops` which records the operations defined by the user but not yet optimised and recorded to the worklist.

An `AdvancedLabware` class is defined, which, in addition to requiring the `location` property, also tracks the last `TransferOperation` to touch each of its wells.
When a `TransferOperation` is created, it records the latest `TransferOperation` referenced at the relevant source and destination wells as `source_dep` and `dest_dep`. An operation will only be considered for optimisation if both of these dependent operations have already been completed. This ensures that all operations on a particular well occur in the order they are defined in code, the same order that they would occur in if `transfer` were used instead. This ensures that, if an `auto_transfer` dispensing diluent to a well occurs before one which dispenses sample, diluent will always be dispensed before sample.

It is assumed that Troughs will only be aspirated from, never dispensed to, so their composition will remain unchanged. Therefore, operation tracking for Troughs is not defined. A `Trough` can be used as the source for an `auto_transfer` (as long as it has the location property set), but not the Destination.

Details of the pending operations can be printed by calling `report_ops`. Operations will be optimised and committed to the worklist whenever `commit()` is called, or when the worklist is saved.

The particulars of how operations are optimised is rather complex, however it is the intention of this package that, as long as a user understands and trusts the `TransferOperation` creation and dependency constraint, they do not need to understand the means by which operations are grouped - they can be confident that all operations will be executed in the order they defined.


### Optimisation Details
The optimiser uses a greedy algorithm; at each step it selects the available operations which can complete the most operations in the least movements of the LiHa. This does not guarantee global optimality - it may sometimes be more efficient to select fewer operations for one step to allow a more efficient grouping for a later step. However, considering such possibilities adds significant design and computational complexity, and in preliminary testing, greedy optimisation is very good; little further benefit would be achieved from ensuring global optimality.

When `commit` is called or a with statement is exited, `make_plan()` is called. This first calls `group_ops` to find the operations which can optimially be executed in one 'step', then, for the most efficient group, creates the Aspirate and Dispense commands necessary to complete these operations. It does this by internal calls to evo_aspirate and evo_dispense, which allows composition tracking and reporting to function as supported by these robotools methods. These steps are repeated until all pending operations have been completed.

`group_ops`  first, finds all `open_ops`; these are the pending operations which do not have any dependencies, or whose dependent operations have already been completed. Then, it creates two types of group: a group by source, and a group by destination. The first step in creating one of these groups is to find all operations which involve a particular column in a particular labware. This is desired as the LiHa can only act on one column of one labware at a given time. When grouping by 'source', a group is created for every column in every labware that has an open operation aspirating from it. This group contains all operations that wish to aspirate from that column, and can be aspirated in one LiHa movement. When grouping by 'destination', groups are created for every column in every labware that open operations wish to dispense to, and we can dispense with one LiHa movement.

Within each of these 'primary' groups, 'seccondary' groups are created. If the primary group is by source, then the secondary groups are by destination, finding, for the ops in the primary group, the destination labwares and columns those ops touch. This determines the number of dispense steps needed for the single aspirate operation.

Further constraints are applied to ensure that each group only uses a particular well once, and to assign tips to each operation. These are explained in the inline comments and documentation.

Groups are sorted by their 'cost', which is the number of steps (Aspirates + Dispenses) they require, divided by the number of operations (well-well transfers) they complete. The group with the lowest cost is selected. If this group does not use all 8 tips, another group may be selected and assigned to the remaining tips.